{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "import { merge } from 'rxjs';\nimport { marbles } from 'rxjs-marbles';\nimport { catchError, map, tap } from 'rxjs/operators';\n\nconst itFunction = global.it ?? global.test\n\n/**\n * The test description\n */\ntype DescriptionString = string;\n\n/**\n * A key-value map of ASCII characters representing stream events to use in tests\n */\ntype StreamMap = Record<string, unknown>;\n\n/**\n * An ASCII-art string representing stream events in Marble notation,\n * using defined mappings\n */\ntype StreamASCII = string;\ntype StreamASCIIRecord = Record<string, StreamASCII>;\ntype TestType = Function & { only: Function; skip: Function; };\n\ntype mappings = {\n  input?: StreamMap\n  output: StreamMap\n};\n\ntype SUT = Function;\ntype MappingsRecord = Record<string, unknown>;\ntype Stubs = unknown[];\n\ntype SpecData = {\n  input?: StreamASCIIRecord;\n  output?: StreamASCIIRecord;\n  subscription?: StreamASCIIRecord;\n  inputs?: StreamASCIIRecord;\n  outputs?: StreamASCIIRecord;\n  subscriptions?: StreamASCIIRecord;\n};\n\nconst _test = (testType: TestType = itFunction, message: DescriptionString, SUT: SUT, stubs: Stubs, mappings: MappingsRecord, streams: SpecData) => {\n  // const staticInputMap = Object.fromEntries(Object.entries(mappings.input).filter(([k, v]) => typeof v != 'function'));\n  // const dynamicInputMap = Object.fromEntries(Object.entries(mappings.input ?? {}).filter(([k, v]) => typeof v == 'function'));\n\n  // const createProxy = (target) => new Proxy(target, {\n  //   get(target, prop, receiver) {\n  //     if (prop in target) {\n  //       const value = Reflect.get(target, prop, receiver);\n  //       if(typeof value == 'function') {\n  //         // if it's a function, call it\n  //         return value(SUT);\n  //       } else {\n  //         return value;\n  //       }\n  //     } else {\n  //       // if it's not mapped, just return itself\n  //       return prop;\n  //     }\n  //   }\n  // });\n \n  testType(message, marbles(context => {\n    const isSingleInput = !!streams.input && !streams.inputs;\n    const isSingleOutput = !!streams.output && !Object.keys(streams.outputs || {}).length;\n    \n    const inputStrings:  Record<string, StreamASCII> = isSingleInput ? {default: streams.input} : streams.inputs;\n    const outputStrings: Record<string, StreamASCII> = isSingleOutput ? {default: streams.output} : streams.outputs;\n\n    const sources$   = Object.fromEntries(Object.entries(inputStrings).map(([k, v]) => [k, context.hot(v,   mappings.input)]));\n    const expecteds$ = Object.fromEntries(Object.entries(outputStrings).map(([k, v]) => [k, context.cold(v, mappings.output)]));\n    const outputs$ = isSingleOutput\n      ? {}\n      : Object.fromEntries(\n          Object.keys(outputStrings)\n            .map(k => [k, stubs[1][k]])\n        )\n    ;\n          \n    const SUTInstance = isSingleInput\n      ? SUT(sources$.default)\n      : SUT(sources$, outputs$)\n    ;\n\n    if(isSingleOutput) {\n      context.expect(SUTInstance).toBeObservable(expecteds$.default);\n    } else {\n      Object.entries(outputs$).forEach(([k, output]) => {\n        const expected = isSingleOutput ? SUTInstance : expecteds$[k];\n        context.expect(output).toBeObservable(expected);\n      });\n    }\n\n    // subscriptions.forEach((subscription, i) => {\n    //   context.expect(sources[i]).toHaveSubscriptions(subscription);\n    // });\n  }));\n};\n\nconst _it   = (...data: [DescriptionString, SUT, Stubs, MappingsRecord, SpecData]) => _test(it, ...data);\nconst _xit  = (...data: [DescriptionString, SUT, Stubs, MappingsRecord, SpecData]) => _test(xit, ...data);\nconst _skip = (...data: [DescriptionString, SUT, Stubs, MappingsRecord, SpecData]) => _test(it.skip, ...data);\nconst _only = (...data: [DescriptionString, SUT, Stubs, MappingsRecord, SpecData]) => _test(it.only, ...data);\n\n_it.only = _only;\n_it.skip = _skip;\n\nexport const observe = {\n  it: _it,\n  xit: _xit,\n  skip: _skip,\n  only: _only,\n};\n\nexport default observe;\n"
  ],
  "mappings": "AACA,kBAAS,sBAGT,IAAM,EAAa,OAAO,IAAM,OAAO,KAsCjC,EAAQ,CAAC,EAAqB,EAAY,EAA4B,EAAU,EAAc,EAA0B,IAAsB,CAqBlJ,EAAS,EAAS,EAAQ,KAAW,CACnC,MAAM,IAAkB,EAAQ,QAAU,EAAQ,OAC5C,IAAmB,EAAQ,SAAW,OAAO,KAAK,EAAQ,SAAW,CAAC,CAAC,EAAE,OAEzE,EAA6C,EAAgB,CAAC,QAAS,EAAQ,KAAK,EAAI,EAAQ,OAChG,EAA6C,EAAiB,CAAC,QAAS,EAAQ,MAAM,EAAI,EAAQ,QAElG,EAAa,OAAO,YAAY,OAAO,QAAQ,CAAY,EAAE,IAAI,EAAE,EAAG,KAAO,CAAC,EAAG,EAAQ,IAAI,EAAK,EAAS,KAAK,CAAC,CAAC,CAAC,EACnH,EAAa,OAAO,YAAY,OAAO,QAAQ,CAAa,EAAE,IAAI,EAAE,EAAG,KAAO,CAAC,EAAG,EAAQ,KAAK,EAAG,EAAS,MAAM,CAAC,CAAC,CAAC,EACpH,EAAW,EACb,CAAC,EACD,OAAO,YACL,OAAO,KAAK,CAAa,EACtB,IAAI,KAAK,CAAC,EAAG,EAAM,GAAG,EAAE,CAAC,CAC9B,EAGE,EAAc,EAChB,EAAI,EAAS,OAAO,EACpB,EAAI,EAAU,CAAQ,EAG1B,GAAG,EACD,EAAQ,OAAO,CAAW,EAAE,eAAe,EAAW,OAAO,MAE7D,QAAO,QAAQ,CAAQ,EAAE,QAAQ,EAAE,EAAG,KAAY,CAChD,MAAM,EAAW,EAAiB,EAAc,EAAW,GAC3D,EAAQ,OAAO,CAAM,EAAE,eAAe,CAAQ,EAC/C,EAMJ,CAAC,GAGE,EAAQ,IAAI,IAAoE,EAAM,GAAI,GAAG,CAAI,EACjG,EAAQ,IAAI,IAAoE,EAAM,IAAK,GAAG,CAAI,EAClG,EAAQ,IAAI,IAAoE,EAAM,GAAG,KAAM,GAAG,CAAI,EACtG,EAAQ,IAAI,IAAoE,EAAM,GAAG,KAAM,GAAG,CAAI,EAE5G,EAAI,KAAO,EACX,EAAI,KAAO,EAEJ,IAAM,EAAU,CACrB,GAAI,EACJ,IAAK,EACL,KAAM,EACN,KAAM,CACR,EAEe",
  "debugId": "D1E7AB971B5334F064756e2164756e21",
  "names": []
}